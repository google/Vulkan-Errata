#! /usr/bin/python3
#
# Copyright 2023 Google LLC
#
# SPDX-License-Identifier: Apache-2.0

import argparse
import glob
import os
import re
import sys
import yaml

template_header = u"""// GENERATED FILE - DO NOT EDIT.
// Generated by scripts/generate.py using data from errata/*.yaml
//
// Copyright 2023 Google LLC
//
// SPDX-License-Identifier: Apache-2.0

#ifndef GOOGLE_VULKAN_ERRATA_H
#define GOOGLE_VULKAN_ERRATA_H

#include <stdbool.h>
#include <vulkan/vulkan_core.h>

{namespace_begin}
{extern_c_begin}

typedef enum {platform_enum_type_prefix} {errata_type_prefix}Platform
{{
{platform_list}
}} {errata_type_prefix}Platform;

typedef struct {errata_type_prefix}KnownIssue
{{
    // Whether the current platform is affected by the issue
    bool affected;
    // What the snake_case name of the issue is
    const char *name;
    // What the camelCase name of the issue is
    const char *camelCaseName;
    // Short description of the issue
    const char *description;
    // The condition to detect the issue
    const char *condition;
}} {errata_type_prefix}KnownIssue;

typedef struct {errata_type_prefix}KnownIssues
{{
{errata_member_list}
}} {errata_type_prefix}KnownIssues;

// Automatically fill in the struct fields based on platform, device and driver properties.
VkResult {errata_function_prefix}GetKnownIssues(
    {errata_type_prefix}Platform platform,
    const VkPhysicalDeviceProperties *device,
    const VkPhysicalDeviceDriverProperties *driver,
    {errata_type_prefix}KnownIssues *issues);

{extern_c_end}
{namespace_end}

#endif  // GOOGLE_VULKAN_ERRATA_H
"""

template_platform = u"""    {platform_enum_prefix}{name},"""

template_issue_member = u"""    struct {errata_type_prefix}KnownIssue {name};"""

template_source = u"""// GENERATED FILE - DO NOT EDIT.
// Generated by scripts/generate.py using data from errata/*.yaml
//
// Copyright 2023 Google LLC
//
// SPDX-License-Identifier: Apache-2.0

#include "vulkan-errata.{header_suffix}"

#include <string.h>

{namespace_begin}

{vendor_list}

static uint32_t NvidiaProprietaryVersion(uint32_t major, uint32_t minor, uint32_t subminor, uint32_t patch)
{{
    return major << 22 | minor << 14 | subminor << 6 | patch;
}}

static uint32_t QualcommProprietaryVersion(uint32_t major, uint32_t minor, uint32_t subminor, uint32_t patch)
{{
    // TODO: find out the correct formula; currently major holds the entire version
    return major;
}}

static uint32_t SamsungProprietaryVersion(uint32_t major, uint32_t minor, uint32_t subminor, uint32_t patch)
{{
    // TODO: find out the correct formula; currently major holds the entire version
    return major;
}}

static uint32_t ArmProprietaryVersion(uint32_t major, uint32_t minor, uint32_t subminor, uint32_t patch)
{{
    return major << 22 | minor << 12 | patch;
}}

static uint32_t IntelOpenSourceMesaVersion(uint32_t major, uint32_t minor, uint32_t subminor, uint32_t patch)
{{
    return major << 22 | minor << 12 | subminor;
}}

static bool IsDriver(const VkPhysicalDeviceProperties *device,
    const VkPhysicalDeviceDriverProperties *driver,
    VkDriverId driverID,
    uint32_t vendorID)
{{
    if (driver != NULL)
    {{
        return driver->driverID == driverID;
    }}
    return device->vendorID == vendorID;
}}

static bool IsDevice(const VkPhysicalDeviceProperties *device,
    const char *substring)
{{
    return strstr(device->deviceName, substring) != NULL;
}}

// Given the conformance version that the driver advertises it has passed and the version in which
// the scenario triggering the bug is known to be tested, decide if the driver is affected by the
// bug.  If the driver has passed at least that conformance version, it's assumed that the bug is
// fixed.
static bool CTSVerified(VkConformanceVersion driverVersion, VkConformanceVersion fixedVersion)
{{
    if (driverVersion.major > fixedVersion.major) return true;
    if (driverVersion.major < fixedVersion.major) return false;

    if (driverVersion.minor > fixedVersion.minor) return true;
    if (driverVersion.minor < fixedVersion.minor) return false;

    if (driverVersion.subminor > fixedVersion.subminor) return true;
    if (driverVersion.subminor < fixedVersion.subminor) return false;

    return driverVersion.patch >= fixedVersion.patch;
}}

VkResult {errata_function_prefix}GetKnownIssues(
    {errata_type_prefix}Platform platform,
    const VkPhysicalDeviceProperties *device,
    const VkPhysicalDeviceDriverProperties *driver,
    {errata_type_prefix}KnownIssues *issues)
{{
    if (device == NULL || issues == NULL)
        return VK_ERROR_INITIALIZATION_FAILED;

    // Short names for platform
{platform_shortname_list}
    if ({neither_platform})
        return VK_ERROR_INCOMPATIBLE_DRIVER;

    // Short names for driver
{driver_shortname_list}
    if ({neither_driver})
        return VK_ERROR_INCOMPATIBLE_DRIVER;

{device_shortname_list}

{errata_member_evaluations}
    return VK_SUCCESS;
}}

{namespace_end}
"""

template_vendor = u"""#define VENDOR_{name} {id}"""

template_platform_shortname = u"""    const bool is{name} = platform == {platform_enum_prefix}{name};"""

template_driver_shortname = u"""    const bool is{name} = IsDriver(device, driver, {id}, VENDOR_{vendor});"""

template_device_shortname = u"""    const bool is{vendor}_{name} = IsDevice(device, {string});"""

template_issue_evaluation = u"""    issues->{name}.affected = {condition};
    issues->{name}.name = "{name}";
    issues->{name}.camelCaseName = "{camel_case}";
    issues->{name}.description = "{description}";
    issues->{name}.condition = "{condition_str}";
"""

platform_list = ['Android', 'ChromeOS', 'Fuchsia', 'IOS', 'Linux', 'Mac',
                 'Windows']

vendor_map = {
    'AMD': '0x1002',
    'ARM': '0x13B5',
    'Broadcom': '0x14E4',
    'GOOGLE': '0x1AE0',
    'ImgTec': '0x1010',
    'Intel': '0x8086',
    'NVIDIA': '0x10DE',
    'Qualcomm': '0x5143',
    'Samsung': '0x144D',
    'VMWare': '0x15ad',
    'Apple': '0x106B',
    'Microsoft': '0x1414',
    'VirtIO': '0x1AF4',
    'Vivante': '0x10001',
    'VeriSilicon': '0x10002',
    'Kazan': '0x10003',
    'CodePlay': '0x10004',
    'Mesa': '0x10005',
    'PoCL': '0x10006',
}

driver_map = {
    'NvidiaProprietary': ('VK_DRIVER_ID_NVIDIA_PROPRIETARY', 'NVIDIA'),
    'QualcommProprietary': ('VK_DRIVER_ID_QUALCOMM_PROPRIETARY', 'Qualcomm'),
    'ArmProprietary': ('VK_DRIVER_ID_ARM_PROPRIETARY', 'ARM'),
    'IntelOpenSourceMesa': ('VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA', 'Intel'),
    'SamsungProprietary': ('VK_DRIVER_ID_SAMSUNG_PROPRIETARY', 'Samsung'),
}

template_readme = u"""<!--
GENERATED FILE - DO NOT EDIT.
Generated by scripts/generate.py using data from errata/*.yaml

Copyright 2023 Google LLC

SPDX-License-Identifier: CC-BY-4.0
-->

# Vulkan Driver Errata Overview

This file is an overview of issues defined in `errata/*.yaml`, sorted by importance.

| Name | Severity | Category | Affected Driver | Affected Devices | Affected Platforms | Fixed in latest drivers? |
|------|:--------:|:--------:|:---------------:|:----------------:|:------------------:|:------------------------:|
{overview_rows}

"""

template_overview_row = u"""| [`{name}`]({name}.md) | {severity} | {category} | {driver} | {devices} | {platforms} | {fixed} |"""

def get_issue_names(db):
    return sorted(db.keys())

def get_devices(device):
    if isinstance(device, list):
        return device
    else:
        return [device]

def get_device_list(db):
    devices = []
    for _,issue in sorted(db.items()):
        conds = issue['affected']
        for cond in conds:
            if 'device' not in cond.keys():
                continue

            # Devices require a driver name just so the associated vendor would be known
            assert('driver' in cond)

            driver = cond['driver']
            vendor = get_vendor_name(driver)

            for device in get_devices(cond['device']):
                devices.append((vendor, device))

    return devices

def make_camel_case(name):
    assert '_' in name, 'feature names in the yaml file are expected to be in snake_case'
    return re.sub('_(.)', lambda m: m.group(1).upper(), name)

def make_platform_list(platform_enum_prefix):
    return '\n'.join(template_platform.format(
            name = name,
            platform_enum_prefix = platform_enum_prefix
        ) for name in platform_list)

def make_issue_members(errata_type_prefix, names):
    return '\n'.join(template_issue_member.format(
            name = name,
            errata_type_prefix = errata_type_prefix
        ) for name in names)

def make_vendor_list():
    return '\n'.join(template_vendor.format(
            name = name,
            id = id,
        ) for name,id in vendor_map.items())

def make_platform_shortnames(platform_enum_prefix):
    return '\n'.join(template_platform_shortname.format(
            name = name,
            platform_enum_prefix = platform_enum_prefix
        ) for name in platform_list)

def make_driver_shortnames():
    return '\n'.join(template_driver_shortname.format(
            name = name,
            id = id,
            vendor = vendor
        ) for name,(id,vendor) in driver_map.items())

def make_device_c_name(name):
    return re.sub('[^0-9a-zA-Z]', '_', name)

def make_device_shortnames(devices):
    return '\n'.join(template_device_shortname.format(
            vendor = vendor,
            name = make_device_c_name(device),
            string = '"' + device + '"'
        ) for vendor,device in devices)

def get_driver_name(driverID):
    for name,(id,_) in driver_map.items():
        if id == driverID:
            return name

    print('Driver ID ' + driverID + ' is missing from driver map')
    assert(False)

def get_vendor_name(driverID):
    for _,(id,vendor) in driver_map.items():
        if id == driverID:
            return vendor

    print('Driver ID ' + driverID + ' is missing from driver map')
    assert(False)

def make_driver_condition(driverID):
    return 'is' + get_driver_name(driverID)

def make_device_condition(driverID, device):
    vendor = get_vendor_name(driverID)
    if isinstance(device, list):
        result = []
        for d in device:
            result.append('is' + vendor + '_' + make_device_c_name(d))
        return '(' + ' || '.join(result) + ')'
    else:
        return 'is' + vendor + '_' + make_device_c_name(device)

def check_platform_inlist(platform):
    if platform not in platform_list:
        print('Platform ' + platform + ' is not in platform list')
        for p in platform_list:
            if platform.lower() == p.lower():
                print('    Did you mean ' + p + '?')
        assert(False)

def make_platform_condition(platform):
    if isinstance(platform, list):
        result = []
        for p in platform:
            check_platform_inlist(p)
            result.append('is' + p)
        return '(' + ' || '.join(result) + ')'
    else:
        check_platform_inlist(platform)
        return 'is' + platform

def get_version_fields(version):
    # Separate the driver version into the major, minor, subminor, patch
    fields = str(version).split('.')

    # Fill missing fields by 0
    return (fields + ['0'] * 3)[:4]

def get_version_uint(driverID, version):
    version_fields = get_version_fields(version)

    # Use a helper function to assemble the version specified in the yaml file into a uint32_t.
    return get_driver_name(driverID) + 'Version(' + ','.join(version_fields) + ')'

def make_version_start_condition(driverID, version):
    return 'device->driverVersion >= ' + get_version_uint(driverID, version)

def make_version_fixed_condition(driverID, version):
    return 'device->driverVersion < ' + get_version_uint(driverID, version)

def get_issue_single_condition(cond):
    # The condition is evaluated is a conjunction of the conditions specified in the yaml file:
    #
    # - `driver: X` evaluates as `driver->driverID == X` (if driver is
    #    provided) or `device->vendorID == vendor(X)`
    # - 'devices: X,Y'` evaluates as `strstr(device, X) || strstr(device, Y)`
    # - `platform: X,Y` evaluates as `platform == X || platform == Y`
    # - `version_start: X` evaluates as `device->driverVersion >= X`
    # - `version_fixed: X` evaluates as `device->driverVersion < X`
    # - `cts_enforced: X` evaluates as `driver->conformanceVersion < X` (if driver is provided)
    #
    # Note that cts_enforced is specified outside the condition list as it's unique.

    # version doesn't make sense without a driver
    assert('driver' in cond or ('version_start' not in cond and 'version_fixed' not in cond))

    result = []
    if 'driver' in cond:
        result.append(make_driver_condition(cond['driver']))
    if 'device' in cond:
        result.append(make_device_condition(cond['driver'], cond['device']))
    if 'platform' in cond:
        result.append(make_platform_condition(cond['platform']))
    if 'version_start' in cond:
        result.append(make_version_start_condition(cond['driver'], cond['version_start']))
    if 'version_fixed' in cond:
        # version doesn't make sense without a driver
        assert('driver' in cond)
        result.append(make_version_fixed_condition(cond['driver'], cond['version_fixed']))

    return '(' + ' && '.join(result) + ')'

def make_cts_enforced_condition(cts_version):
    fields = get_version_fields(cts_version)
    conformance_version = 'VkConformanceVersion{' + ','.join(fields) + '}'

    return '(driver == NULL || !CTSVerified(driver->conformanceVersion, ' + conformance_version + '))'

def make_issue_condition(cond_list, cts_version):
    conds = [get_issue_single_condition(cond) for cond in cond_list]
    conds = ' ||\n        '.join(conds)

    if cts_version is not None:
        conds = get_issue_cts_enforced_condition(cts_version) + ' &&\n        (' + conts + ')'

    return conds

def make_condition_str(condition):
    # Remove formatting from the condition to create a single-line string
    return re.sub('\s+', ' ', condition)

def make_issue_evaluation(name, issue):
    condition = make_issue_condition(issue['affected'], issue.get('cts_enforced'))
    condition_str = make_condition_str(condition)
    name = name
    camel_case_name = make_camel_case(name)
    description = issue['description'].strip()

    return template_issue_evaluation.format(
        name = name,
        camel_case = camel_case_name,
        condition = condition,
        condition_str = condition_str,
        description = description)

def make_issue_evaluations(db):
    result = []
    for name,issue in sorted(db.items()):
        result.append(make_issue_evaluation(name, issue))
    return '\n'.join(result)

def make_header_and_source(header_suffix, namespace_begin, namespace_end,
                extern_c_begin, extern_c_end,
                errata_type_prefix, errata_function_prefix,
                platform_enum_type_prefix, platform_enum_prefix, platform_enum_qualifier,
                names, devices, evaluations):

    platforms = make_platform_list(platform_enum_prefix)
    errata_member_list = make_issue_members(errata_type_prefix, names)

    header = template_header.format(
        namespace_begin = namespace_begin,
        namespace_end = namespace_end,
        extern_c_begin = extern_c_begin,
        extern_c_end = extern_c_end,
        errata_type_prefix = errata_type_prefix,
        errata_function_prefix = errata_function_prefix,
        platform_enum_type_prefix = platform_enum_type_prefix,
        platform_list = platforms,
        errata_member_list = errata_member_list)

    vendor_list = make_vendor_list()
    platform_shortname_list = make_platform_shortnames(platform_enum_qualifier + platform_enum_prefix)
    driver_shortname_list = make_driver_shortnames()
    device_shortname_list = make_device_shortnames(devices)
    neither_platform = ' && '.join(['!is' + name for name in platform_list])
    neither_driver = ' && '.join(['!is' + name for name in driver_map.keys()])

    source = template_source.format(
        header_suffix = header_suffix,
        namespace_begin = namespace_begin,
        namespace_end = namespace_end,
        vendor_list = vendor_list,
        errata_type_prefix = errata_type_prefix,
        errata_function_prefix = errata_function_prefix,
        platform_enum_type_prefix = platform_enum_type_prefix,
        platform_shortname_list = platform_shortname_list,
        driver_shortname_list = driver_shortname_list,
        device_shortname_list = device_shortname_list,
        neither_platform = neither_platform,
        neither_driver = neither_driver,
        errata_member_evaluations = evaluations)

    return header, source

severity_rank_map = {
    'high': 0,
    'low': 1,
}

category_rank_map = {
    'crash': 0,
    'rendering': 1,
    'performance': 2,
}

def get_fixed_rank(fixed):
    # The worst bugs are those that are not fixed
    if fixed:
        return 0
    return 1

def get_issue_rank(issue):
    name, severity, category, _, _, _, fixed = issue

    severity_rank = severity_rank_map[severity]
    category_rank = category_rank_map[category]
    fixed_rank = get_fixed_rank(fixed)

    # Sort first by fixed or not, then severity, then category, and if all else is equal, by name.
    return (fixed_rank, severity_rank, category_rank, name)

def get_issues_overview(db):
    issue_list = []

    for name,issue in db.items():
        severity = issue['severity']
        category = issue['category']
        affected = issue['affected']

        for cond in affected:
            platform = cond.get('platform', 'All')
            driver = get_driver_name(cond['driver']) if 'driver' in cond else 'All'
            devices = ', '.join(get_devices(cond['device'])) if 'device' in cond else 'All'
            fixed = 'version_fixed' in cond

            issue_list.append((name, severity, category, platform, driver, devices, fixed))

    issue_list.sort(key=get_issue_rank)
    return issue_list

def make_overview_row(issue):
    name, severity, category, platform, driver, devices, fixed = issue

    return template_overview_row.format(
        name = name,
        severity = severity,
        category = category,
        driver = driver,
        devices = devices,
        platforms = platform,
        fixed = 'Yes' if fixed else 'No')

def make_readme(overview):
    rows = '\n'.join([make_overview_row(issue) for issue in overview])

    return template_readme.format(overview_rows = rows)

def load_database(rootdir):
    db = {}

    # Load at all *.yaml files.
    for file in glob.glob(os.path.join(rootdir, 'errata', '*.yaml')):
        with open(file) as fin:
            entry = yaml.safe_load(fin)

            # There should be one one entry per file
            entry_count = len(entry) if entry is not None else 0
            if entry_count != 1:
                print('Please individually split entries among files.  {} entries found in {}'.format(entry_count, file))
                sys.exit(1)

            # The entry name must match the file name
            issue_name = list(entry.keys())[0]
            expected = os.path.join(rootdir, 'errata', issue_name + '.yaml')
            if file != expected:
                print('Please name the yaml files identically to their issue name.  {} found in {}'.format(issue_name, file))
                sys.exit(1)

            # The entry must be unique
            if issue_name in db.keys():
                print('Please use unique names for issues.  Duplicate name {} found in {}'.format(issue_name, file))
                sys.exit(1)

            # Merge the entry with the database
            db |= entry

    return db

def main():
    parser = argparse.ArgumentParser()

    parser.add_argument('--outdir', action='store',
                        default=None,
                        help='Specify output directory for generated files')

    args = parser.parse_args()

    rootdir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))

    # Default output directory to ../src/
    outdir = args.outdir
    if outdir is None:
        outdir = os.path.abspath(os.path.join(rootdir, 'src'))

    # Default doc directory to ../doc/
    # Note that when --outdir is specified, doc output is placed next to source files.  This option
    # is only used by CI to generate the files elsewhere.
    docdir = args.outdir
    if docdir is None:
        docdir = os.path.abspath(os.path.join(rootdir, 'doc'))

    # Load the database
    db = load_database(rootdir)

    # Get the issue names for the headers
    names = get_issue_names(db)

    # Get the device architecture names used throughout the database
    devices = get_device_list(db)

    # Get the issue evaluations
    evaluations = make_issue_evaluations(db)

    extern_c_begin = """#ifdef __cplusplus
extern "C" {
#endif"""
    extern_c_end = """#ifdef __cplusplus
}
#endif"""

    # Generate and write the
    c_header, c_source = make_header_and_source(
        header_suffix = 'h',
        namespace_begin = '',
        namespace_end = '',
        extern_c_begin = extern_c_begin,
        extern_c_end = extern_c_end,
        errata_type_prefix = 'VulkanErrata',
        errata_function_prefix = 'vulkanErrata',
        platform_enum_type_prefix = '',
        platform_enum_prefix = 'VulkanErrataPlatform',
        platform_enum_qualifier = '',
        names = names,
        devices = devices,
        evaluations = evaluations)

    cpp_header, cpp_source = make_header_and_source(
        header_suffix = 'hpp',
        namespace_begin = 'namespace vulkan_errata {',
        namespace_end = '}  // namespace vulkan_errata',
        extern_c_begin = '',
        extern_c_end = '',
        errata_type_prefix = '',
        errata_function_prefix = '',
        platform_enum_type_prefix = 'class',
        platform_enum_prefix = '',
        platform_enum_qualifier = 'vulkan_errata::Platform::',
        names = names,
        devices = devices,
        evaluations = evaluations)

    targets = {
        'h': c_header,
        'c': c_source,
        'hpp': cpp_header,
        'cpp': cpp_source,
    }

    for suffix,text in targets.items():
        filename = os.path.join(outdir, 'vulkan-errata.' + suffix)
        with open(filename, 'w', encoding='utf8', newline='\n') as fout:
            fout.write(text)

    # Create a table that presents an overview of all issues, sorted such that the issues that are
    # more pressing or placed first.
    overview = get_issues_overview(db)
    readme = make_readme(overview)

    with open(os.path.join(docdir, 'README.md'), 'w', encoding='utf8', newline='\n') as fout:
        fout.write(readme)

if __name__ == '__main__':
    sys.exit(main())
